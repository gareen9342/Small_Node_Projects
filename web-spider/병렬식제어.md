지금까지 for 문을 돌려 비동시적 작업을 처리시   
이 제어를 이벤트 루프에게 맡기면 이벤트루프가 메인 쪽에서는 비동기적 작업을 실행안하고 던져버리고 다른 작업을 처리하게 되니   
저절로 어느정도는 병렬적 제어 (리소스를 나눠가지게 되는 이벤트 루프의 흐름)가 가능하고, 병렬적 제어라고 할 수 있는 줄 알았지만    
이번에 새로 공부하게 되면서 이는 엄밀이 말하면 동시성에 관한 이야기임을 알게되었다.    
바꿔말하면, 병렬이라는 용어는 부적절하다는 것을 의미한다.

어쨌든 저쨌든...개발하면서 종종 느끼는 것은 비동기적 제어를 잘 활용하기만 하면 n초 단위로 빨라지게 할 수 있다는 것. 
노드는 핵심 패턴을 깊게 파헤쳐야겠다는 생각이 든다. 

예를 들면 아래와 같이 처리하게 될 경우 비동기적제어는 메인 이벤트에서 실행이 되지 않고 백그라운드로 넘어가게 된다.

```javascript
const tasks = [1,2,3,...]

let completed = 0

tasks.forEach(task => {
    if(++completed === tasks.length){
        finish()
    }
})

```

이런 식으로 생각하면 된다. 비동기함수는 논블로킹 API에 의해서 처리되게 된다. 
또한 이러한 병렬처리시, 외부 리소스 접근에 대한 경쟁이 일어날 수 있다. (에를 들어, 파일이나 데이터 베이스에 대한 접근과 같은 것들 나도 이런 점을 제어하려다가 최근 에러를 맛보아서 ㅠ_ㅜ)
쉬운 예를 들면, 같은 파일에 대해 동일한 readFile을 동시에 호출을 한다던가, 동일한 데이터 접근 등에 관한 것이다. 


이러한 경쟁 상태를 가지게 되는 것을 전문용어로 경쟁상태 (race condition) 이라고 말할 수 있다. 

책에서는 이렇게 설명한다. 

수많은 파일을 읽거나, URL에 대한 접근, 데이터베이스에 대한 쿼리를 병렬로 실행한다고 가정할 때에, 가장 많이 발생하는 문제는 리소스의 부족이다.     
또한 보안적으로 DOS공격에 취약할 수 있다.   
하나의 기능이 너무 많은 작업을 처리하는 API가 있다고 가정한다면, 악의적인 해커가 하나 이상의 요청을 서버에 보냄으로써 서버가 리소스를 소비하게 하고, 응답이 불가능하게 만들 수 있는 것이다. 

해결법은 동시적 처리시에 동시처리 일의 최대 갯수를 정해주는 조건을 정해주면 된다. 


